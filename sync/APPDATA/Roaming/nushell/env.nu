# Nushell Environment Config File
#
# version = 0.83.1

def get_dir [] {
    mut home = ""
    try {
        if $nu.os-info.name == "windows" {
            $home = $env.USERPROFILE
        } else {
            $home = $env.HOME
        }
    }
 # 
    let path = [
        ($env.PWD | str substring 0..($home | str length) | str replace --string $home "🏠"),
        ($env.PWD | str substring ($home | str length)..)
    ] | str join


    let path_color = (if (is-admin) { ansi red_bold } else { ansi green_bold })
    # let separator_color = (if (is-admin) { ansi light_red_bold } else { ansi light_blue_bold })

    let path = $path | str replace --all --string (char path_sep) "/"

    let path = $path | str replace --string "github.com" " "

    $path
}

def create_left_prompt [] {

    let last_exit_code = if ($env.LAST_EXIT_CODE != 0) {([
        (ansi rb)
        ($env.LAST_EXIT_CODE)
    ] | str join)
    } else { "0" }

    def push [stat, text, fg, bg] {
        {
            text: $"($stat.text) (ansi {fg: $stat.bg, bg: $bg}) (ansi {fg: $fg bg: $bg})($text)"
            bg: $bg
        }
    }

    let stat = {
        text: $"(ansi {fg:black bg:yellow})(get_dir)"
        bg: yellow
    }

    let g = gstat
    let stat = if (($g.branch == 'master') or ($g.branch == 'main')) {
        (push $stat $" ($g.branch)" white green)
    } else {
        (push $stat $" ($g.branch)" white red) 
    }
    let stat = (push $stat "" default default)

    $"($stat.text)\n($last_exit_code)"
}

def create_right_prompt [] {
    let g = gstat
    if ($g.repo_name != 'no_repository') {
        mut info = ""
        if ($g.wt_untracked > 0 
            or $g.wt_modified > 0 
            or $g.wt_deleted > 0 
            or $g.wt_type_changed > 0 
            or $g.wt_renamed > 0 
        ) {
            $info += $"(ansi {fg:black bg:red})*"
        }
        $info
    } else {
        ""
    }
}

# Use nushell functions to define your right and left prompt
# $env.PROMPT_COMMAND = {|| create_left_prompt }
$env.PROMPT_COMMAND = {|| create_left_prompt }
$env.PROMPT_COMMAND_RIGHT = {|| create_right_prompt }

# The prompt indicators are environmental variables that represent
# the state of the prompt
$env.PROMPT_INDICATOR = {|| "> " }
$env.PROMPT_INDICATOR_VI_INSERT = {|| ": " }
$env.PROMPT_INDICATOR_VI_NORMAL = {|| "> " }
$env.PROMPT_MULTILINE_INDICATOR = {|| "::: " }

# Specifies how environment variables are:
# - converted from a string to a value on Nushell startup (from_string)
# - converted from a value back to a string when running external commands (to_string)
# Note: The conversions happen *after* config.nu is loaded
$env.ENV_CONVERSIONS = {
    "PATH": {
        from_string: { |s| $s | split row (char esep) | path expand --no-symlink }
        to_string: { |v| $v | path expand --no-symlink | str join (char esep) }
    }
    "Path": {
        from_string: { |s| $s | split row (char esep) | path expand --no-symlink }
        to_string: { |v| $v | path expand --no-symlink | str join (char esep) }
    }
}

# Directories to search for scripts when calling source or use
$env.NU_LIB_DIRS = [
    # ($nu.default-config-dir | path join 'scripts') # add <nushell-config-dir>/scripts
]

# Directories to search for plugin binaries when calling register
$env.NU_PLUGIN_DIRS = [
    # ($nu.default-config-dir | path join 'plugins') # add <nushell-config-dir>/plugins
]

# To add entries to PATH (on Windows you might use Path), you can use the following pattern:
# $env.PATH = ($env.PATH | split row (char esep) | prepend '/some/path')

# alias ll = (ls | grid -c)
def la [] { ls -a | where name !~ 'NTUSER.DAT' | where name !~ 'Microsoft.' | grid -c }
def ll [] { ls -l | where name !~ 'NTUSER.DAT' | where name !~ 'Microsoft.' }

# ghq go
def-env gg [] {
    ghq list --full-path | fzf --preview $"bat --color=always --style=header,grid --line-range :80 {}/README.*" | decode utf-8 | str trim | cd $in
}

# git switch
def gs [] {
    git branch | lines | str trim | where { |s| 
        let xx = $s | str substring 0..2
        $xx != "* "
    } | str join "\n" | fzf --preview "git show --color=always {}" | str trim | git switch $in
}

# meson wrap 
def mewrap [] {
    meson wrap list | fzf --preview "meson wrap info{}" | str trim | meson wrap install $in
}

# fdir
def fz [path] {
    rg --files $path | fzf --preview $"bat --color=always {}"
}

def gt [] {
    git status
}

# Code generated by zoxide. DO NOT EDIT.

# =============================================================================
#
# Hook configuration for zoxide.
#

# Initialize hook to add new entries to the database.
if (not ($env | default false __zoxide_hooked | get __zoxide_hooked)) {
  $env.__zoxide_hooked = true
  $env.config = ($env | default {} config).config
  $env.config = ($env.config | default {} hooks)
  $env.config = ($env.config | update hooks ($env.config.hooks | default {} env_change))
  $env.config = ($env.config | update hooks.env_change ($env.config.hooks.env_change | default [] PWD))
  $env.config = ($env.config | update hooks.env_change.PWD ($env.config.hooks.env_change.PWD | append {|_, dir|
    zoxide add -- $dir
  }))
}

# =============================================================================
#
# When using zoxide with --no-cmd, alias these internal functions as desired.
#

# Jump to a directory using only keywords.
def-env __zoxide_z [...rest:string] {
  let arg0 = ($rest | append '~').0
  let path = if (($rest | length) <= 1) and ($arg0 == '-' or ($arg0 | path expand | path type) == dir) {
    $arg0
  } else {
    (zoxide query --exclude $env.PWD -- $rest | str trim -r -c "\n")
  }
  cd $path
}

# Jump to a directory using interactive search.
def-env __zoxide_zi  [...rest:string] {
  cd $'(zoxide query --interactive -- $rest | str trim -r -c "\n")'
}

# =============================================================================
#
# Commands for zoxide. Disable these using --no-cmd.
#

alias z = __zoxide_z
alias zi = __zoxide_zi

# =============================================================================
#
# Add this to your env file (find it by running `$nu.env-path` in Nushell):
#
#   zoxide init nushell | save -f ~/.zoxide.nu
#
# Now, add this to the end of your config file (find it by running
# `$nu.config-path` in Nushell):
#
#   source ~/.zoxide.nu
#
# Note: zoxide only supports Nushell v0.73.0 and above.

